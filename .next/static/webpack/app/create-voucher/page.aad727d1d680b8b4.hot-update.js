"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/create-voucher/page",{

/***/ "(app-pages-browser)/./src/components/voucherPDF/VoucherPDF.tsx":
/*!**************************************************!*\
  !*** ./src/components/voucherPDF/VoucherPDF.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateVoucherPDF: function() { return /* binding */ generateVoucherPDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! qrcode */ \"(app-pages-browser)/./node_modules/qrcode/lib/browser.js\");\n\n\n/**\n * Generates a minimalist PDF for vouchers\n */ const generateVoucherPDF = async (voucher)=>{\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        orientation: \"landscape\",\n        unit: \"mm\",\n        format: \"a5\"\n    });\n    // Define minimalist colors - monochromatic scheme\n    const primaryColor = voucher.primaryColor || \"#333333\";\n    const secondaryColor = voucher.secondaryColor || \"#666666\";\n    const textColor = voucher.textColor || \"#333333\";\n    // Convert hex colors to RGB for jsPDF\n    const primaryRGB = hexToRgb(primaryColor);\n    const secondaryRGB = hexToRgb(secondaryColor);\n    const textRGB = hexToRgb(textColor);\n    // Get page dimensions\n    const width = doc.internal.pageSize.getWidth();\n    const height = doc.internal.pageSize.getHeight();\n    // Add clean white background\n    doc.setFillColor(255, 255, 255);\n    doc.rect(0, 0, width, height, \"F\");\n    // Add minimal border\n    doc.setDrawColor(primaryRGB.r, primaryRGB.g, primaryRGB.b, 0.3);\n    doc.setLineWidth(0.5);\n    doc.rect(10, 10, width - 20, height - 20, \"S\");\n    // Add company logo (if available)\n    if (voucher.logoUrl) {\n        try {\n            // Convert logo URL to Base64\n            const response = await fetch(voucher.logoUrl);\n            const blob = await response.blob();\n            const reader = new FileReader();\n            const base64Promise = new Promise((resolve, reject)=>{\n                reader.onloadend = ()=>resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n            const base64Logo = await base64Promise;\n            // Create an image element to get the original dimensions\n            const img = new Image();\n            img.src = base64Logo;\n            await new Promise((resolve)=>{\n                img.onload = resolve;\n            });\n            const originalWidth = img.width;\n            const originalHeight = img.height;\n            // Define the maximum and minimum width and height for the logo\n            const maxWidth = 40; // Maximum width in mm\n            const maxHeight = 20; // Maximum height in mm\n            // Calculate the aspect ratio\n            let logoWidth = maxWidth;\n            let logoHeight = maxHeight;\n            if (originalWidth > originalHeight) {\n                // Landscape logo\n                logoHeight = originalHeight / originalWidth * maxWidth;\n            } else {\n                // Portrait or square logo\n                logoWidth = originalWidth / originalHeight * maxHeight;\n            }\n            // Position the logo\n            const logoX = width - 60; // Position X (right side)\n            const logoY = 20; // Position Y (aligned with the top)\n            doc.addImage(base64Logo, \"PNG\", logoX, logoY, logoWidth, logoHeight);\n        } catch (error) {\n            console.error(\"Error loading logo:\", error);\n            // Create a placeholder for the logo\n            const placeholderWidth = 40;\n            const placeholderHeight = 20;\n            const placeholderX = width - 60;\n            const placeholderY = 20;\n            doc.setFillColor(240, 240, 240);\n            doc.rect(placeholderX, placeholderY, placeholderWidth, placeholderHeight, \"F\");\n        }\n    }\n    // Adjusted position for the voucher name\n    doc.setFontSize(24);\n    doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(voucher.name || \"Gift Voucher\", 20, 40); // Name of the voucher (moved down)\n    // Adjusted position for the voucher description\n    if (voucher.description) {\n        doc.setFontSize(10);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n        doc.text(voucher.description, 20, 50, {\n            maxWidth: width - 80\n        }); // Description with adjusted margin\n    }\n    // Divider position adjusted\n    const dividerY = voucher.description ? 65 : 55;\n    doc.setDrawColor(primaryRGB.r, primaryRGB.g, primaryRGB.b, 0.2);\n    doc.setLineWidth(0.3);\n    doc.line(20, dividerY, width - 20, dividerY);\n    // Amount and currency display (if available)\n    const amountY = dividerY + 15;\n    if (voucher.amount && voucher.currency) {\n        doc.setFontSize(18);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n        doc.text(\"\".concat(voucher.amount, \" \").concat(voucher.currency), 20, amountY);\n    }\n    // Voucher code display\n    const codeY = amountY + 15;\n    doc.setFontSize(8);\n    doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(\"VOUCHER CODE\", 20, codeY);\n    doc.setFontSize(16);\n    doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n    doc.setFont(\"courier\", \"normal\");\n    doc.text(voucher.code, 20, codeY + 8);\n    // Generate QR code for the voucher code\n    let qrCodeData = voucher.qrCode;\n    if (!qrCodeData) {\n        try {\n            qrCodeData = await qrcode__WEBPACK_IMPORTED_MODULE_1__.toDataURL(voucher.code, {\n                errorCorrectionLevel: \"M\",\n                margin: 1,\n                color: {\n                    dark: textColor,\n                    light: \"#FFFFFF\"\n                }\n            });\n        } catch (error) {\n            console.error(\"Error generating QR Code:\", error);\n        }\n    }\n    // Add QR code\n    if (qrCodeData) {\n        const qrSize = 30;\n        const qrX = width - 50;\n        const qrY = height - 50;\n        doc.addImage(qrCodeData, \"PNG\", qrX, qrY, qrSize, qrSize);\n    }\n    // Expiry date\n    if (voucher.expiryDate) {\n        const expiryDate = new Date(voucher.expiryDate);\n        const formattedDate = expiryDate.toLocaleDateString(\"en-US\", {\n            year: \"numeric\",\n            month: \"long\",\n            day: \"numeric\"\n        });\n        doc.setFontSize(10);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n        doc.text(\"Valid until: \".concat(formattedDate), 20, height - 20);\n    }\n    // Status indicator\n    if (voucher.status) {\n        const statusY = 20;\n        const statusColor = getMinimalistStatusColor(voucher.status);\n        const statusRGB = hexToRgb(statusColor);\n        doc.setFontSize(10);\n        doc.setTextColor(statusRGB.r, statusRGB.g, statusRGB.b);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(voucher.status.toUpperCase(), width - 20, statusY, {\n            align: \"right\"\n        });\n    }\n    // Return the PDF as a Blob\n    return doc.output(\"blob\");\n};\n/**\n * Returns a muted color based on voucher status for minimalist design\n */ function getMinimalistStatusColor(status) {\n    switch(status.toLowerCase()){\n        case \"active\":\n            return \"#4B9D74\";\n        case \"used\":\n            return \"#9CA3AF\";\n        case \"expired\":\n            return \"#DC6F79\";\n        case \"pending\":\n            return \"#D7A45E\";\n        default:\n            return \"#6B7280\";\n    }\n}\nfunction hexToRgb(hex) {\n    hex = hex.replace(/^#/, \"\");\n    if (hex.length === 3) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    }\n    const bigint = parseInt(hex, 16);\n    const r = bigint >> 16 & 255;\n    const g = bigint >> 8 & 255;\n    const b = bigint & 255;\n    return {\n        r,\n        g,\n        b\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3ZvdWNoZXJQREYvVm91Y2hlclBERi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQ0U7QUF5QjVCOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCLE9BQU9DO0lBQ3ZDLE1BQU1DLE1BQU0sSUFBSUosNkNBQUtBLENBQUM7UUFDcEJLLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxRQUFRO0lBQ1Y7SUFFQSxrREFBa0Q7SUFDbEQsTUFBTUMsZUFBZUwsUUFBUUssWUFBWSxJQUFJO0lBQzdDLE1BQU1DLGlCQUFpQk4sUUFBUU0sY0FBYyxJQUFJO0lBQ2pELE1BQU1DLFlBQVlQLFFBQVFPLFNBQVMsSUFBSTtJQUV2QyxzQ0FBc0M7SUFDdEMsTUFBTUMsYUFBYUMsU0FBU0o7SUFDNUIsTUFBTUssZUFBZUQsU0FBU0g7SUFDOUIsTUFBTUssVUFBVUYsU0FBU0Y7SUFFekIsc0JBQXNCO0lBQ3RCLE1BQU1LLFFBQVFYLElBQUlZLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxRQUFRO0lBQzVDLE1BQU1DLFNBQVNmLElBQUlZLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDRyxTQUFTO0lBRTlDLDZCQUE2QjtJQUM3QmhCLElBQUlpQixZQUFZLENBQUMsS0FBSyxLQUFLO0lBQzNCakIsSUFBSWtCLElBQUksQ0FBQyxHQUFHLEdBQUdQLE9BQU9JLFFBQVE7SUFFOUIscUJBQXFCO0lBQ3JCZixJQUFJbUIsWUFBWSxDQUFDWixXQUFXYSxDQUFDLEVBQUViLFdBQVdjLENBQUMsRUFBRWQsV0FBV2UsQ0FBQyxFQUFFO0lBQzNEdEIsSUFBSXVCLFlBQVksQ0FBQztJQUNqQnZCLElBQUlrQixJQUFJLENBQUMsSUFBSSxJQUFJUCxRQUFRLElBQUlJLFNBQVMsSUFBSTtJQUUxQyxrQ0FBa0M7SUFDbEMsSUFBSWhCLFFBQVF5QixPQUFPLEVBQUU7UUFDbkIsSUFBSTtZQUNGLDZCQUE2QjtZQUM3QixNQUFNQyxXQUFXLE1BQU1DLE1BQU0zQixRQUFReUIsT0FBTztZQUM1QyxNQUFNRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7WUFDaEMsTUFBTUMsU0FBUyxJQUFJQztZQUVuQixNQUFNQyxnQkFBZ0IsSUFBSUMsUUFBZ0IsQ0FBQ0MsU0FBU0M7Z0JBQ2xETCxPQUFPTSxTQUFTLEdBQUcsSUFBTUYsUUFBUUosT0FBT08sTUFBTTtnQkFDOUNQLE9BQU9RLE9BQU8sR0FBR0g7Z0JBQ2pCTCxPQUFPUyxhQUFhLENBQUNWO1lBQ3ZCO1lBRUEsTUFBTVcsYUFBYSxNQUFNUjtZQUV6Qix5REFBeUQ7WUFDekQsTUFBTVMsTUFBTSxJQUFJQztZQUNoQkQsSUFBSUUsR0FBRyxHQUFHSDtZQUVWLE1BQU0sSUFBSVAsUUFBUSxDQUFDQztnQkFDakJPLElBQUlHLE1BQU0sR0FBR1Y7WUFDZjtZQUVBLE1BQU1XLGdCQUFnQkosSUFBSTVCLEtBQUs7WUFDL0IsTUFBTWlDLGlCQUFpQkwsSUFBSXhCLE1BQU07WUFFakMsK0RBQStEO1lBQy9ELE1BQU04QixXQUFXLElBQUksc0JBQXNCO1lBQzNDLE1BQU1DLFlBQVksSUFBSSx1QkFBdUI7WUFFN0MsNkJBQTZCO1lBQzdCLElBQUlDLFlBQVlGO1lBQ2hCLElBQUlHLGFBQWFGO1lBRWpCLElBQUlILGdCQUFnQkMsZ0JBQWdCO2dCQUNsQyxpQkFBaUI7Z0JBQ2pCSSxhQUFhLGlCQUFrQkwsZ0JBQWlCRTtZQUNsRCxPQUFPO2dCQUNMLDBCQUEwQjtnQkFDMUJFLFlBQVksZ0JBQWlCSCxpQkFBa0JFO1lBQ2pEO1lBRUEsb0JBQW9CO1lBQ3BCLE1BQU1HLFFBQVF0QyxRQUFRLElBQUksMEJBQTBCO1lBQ3BELE1BQU11QyxRQUFRLElBQUksb0NBQW9DO1lBRXREbEQsSUFBSW1ELFFBQVEsQ0FBQ2IsWUFBWSxPQUFPVyxPQUFPQyxPQUFPSCxXQUFXQztRQUMzRCxFQUFFLE9BQU9JLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHVCQUF1QkE7WUFFckMsb0NBQW9DO1lBQ3BDLE1BQU1FLG1CQUFtQjtZQUN6QixNQUFNQyxvQkFBb0I7WUFDMUIsTUFBTUMsZUFBZTdDLFFBQVE7WUFDN0IsTUFBTThDLGVBQWU7WUFFckJ6RCxJQUFJaUIsWUFBWSxDQUFDLEtBQUssS0FBSztZQUMzQmpCLElBQUlrQixJQUFJLENBQUNzQyxjQUFjQyxjQUFjSCxrQkFBa0JDLG1CQUFtQjtRQUM1RTtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDdkQsSUFBSTBELFdBQVcsQ0FBQztJQUNoQjFELElBQUkyRCxZQUFZLENBQUNqRCxRQUFRVSxDQUFDLEVBQUVWLFFBQVFXLENBQUMsRUFBRVgsUUFBUVksQ0FBQztJQUNoRHRCLElBQUk0RCxPQUFPLENBQUMsYUFBYTtJQUN6QjVELElBQUk2RCxJQUFJLENBQUM5RCxRQUFRK0QsSUFBSSxJQUFJLGdCQUFnQixJQUFJLEtBQUssbUNBQW1DO0lBRXJGLGdEQUFnRDtJQUNoRCxJQUFJL0QsUUFBUWdFLFdBQVcsRUFBRTtRQUN2Qi9ELElBQUkwRCxXQUFXLENBQUM7UUFDaEIxRCxJQUFJNEQsT0FBTyxDQUFDLGFBQWE7UUFDekI1RCxJQUFJMkQsWUFBWSxDQUFDbEQsYUFBYVcsQ0FBQyxFQUFFWCxhQUFhWSxDQUFDLEVBQUVaLGFBQWFhLENBQUM7UUFDL0R0QixJQUFJNkQsSUFBSSxDQUFDOUQsUUFBUWdFLFdBQVcsRUFBRSxJQUFJLElBQUk7WUFBRWxCLFVBQVVsQyxRQUFRO1FBQUcsSUFBSSxtQ0FBbUM7SUFDdEc7SUFFQSw0QkFBNEI7SUFDNUIsTUFBTXFELFdBQVdqRSxRQUFRZ0UsV0FBVyxHQUFHLEtBQUs7SUFDNUMvRCxJQUFJbUIsWUFBWSxDQUFDWixXQUFXYSxDQUFDLEVBQUViLFdBQVdjLENBQUMsRUFBRWQsV0FBV2UsQ0FBQyxFQUFFO0lBQzNEdEIsSUFBSXVCLFlBQVksQ0FBQztJQUNqQnZCLElBQUlpRSxJQUFJLENBQUMsSUFBSUQsVUFBVXJELFFBQVEsSUFBSXFEO0lBRW5DLDZDQUE2QztJQUM3QyxNQUFNRSxVQUFVRixXQUFXO0lBQzNCLElBQUlqRSxRQUFRb0UsTUFBTSxJQUFJcEUsUUFBUXFFLFFBQVEsRUFBRTtRQUN0Q3BFLElBQUkwRCxXQUFXLENBQUM7UUFDaEIxRCxJQUFJNEQsT0FBTyxDQUFDLGFBQWE7UUFDekI1RCxJQUFJMkQsWUFBWSxDQUFDakQsUUFBUVUsQ0FBQyxFQUFFVixRQUFRVyxDQUFDLEVBQUVYLFFBQVFZLENBQUM7UUFDaER0QixJQUFJNkQsSUFBSSxDQUFDLEdBQXFCOUQsT0FBbEJBLFFBQVFvRSxNQUFNLEVBQUMsS0FBb0IsT0FBakJwRSxRQUFRcUUsUUFBUSxHQUFJLElBQUlGO0lBQ3hEO0lBRUEsdUJBQXVCO0lBQ3ZCLE1BQU1HLFFBQVFILFVBQVU7SUFFeEJsRSxJQUFJMEQsV0FBVyxDQUFDO0lBQ2hCMUQsSUFBSTJELFlBQVksQ0FBQ2xELGFBQWFXLENBQUMsRUFBRVgsYUFBYVksQ0FBQyxFQUFFWixhQUFhYSxDQUFDO0lBQy9EdEIsSUFBSTRELE9BQU8sQ0FBQyxhQUFhO0lBQ3pCNUQsSUFBSTZELElBQUksQ0FBQyxnQkFBZ0IsSUFBSVE7SUFFN0JyRSxJQUFJMEQsV0FBVyxDQUFDO0lBQ2hCMUQsSUFBSTJELFlBQVksQ0FBQ2pELFFBQVFVLENBQUMsRUFBRVYsUUFBUVcsQ0FBQyxFQUFFWCxRQUFRWSxDQUFDO0lBQ2hEdEIsSUFBSTRELE9BQU8sQ0FBQyxXQUFXO0lBQ3ZCNUQsSUFBSTZELElBQUksQ0FBQzlELFFBQVF1RSxJQUFJLEVBQUUsSUFBSUQsUUFBUTtJQUVuQyx3Q0FBd0M7SUFDeEMsSUFBSUUsYUFBYXhFLFFBQVF5RSxNQUFNO0lBQy9CLElBQUksQ0FBQ0QsWUFBWTtRQUNmLElBQUk7WUFDRkEsYUFBYSxNQUFNMUUsNkNBQWdCLENBQUNFLFFBQVF1RSxJQUFJLEVBQUU7Z0JBQ2hESSxzQkFBc0I7Z0JBQ3RCQyxRQUFRO2dCQUNSQyxPQUFPO29CQUNMQyxNQUFNdkU7b0JBQ053RSxPQUFPO2dCQUNUO1lBQ0Y7UUFDRixFQUFFLE9BQU8xQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyw2QkFBNkJBO1FBQzdDO0lBQ0Y7SUFFQSxjQUFjO0lBQ2QsSUFBSW1CLFlBQVk7UUFDZCxNQUFNUSxTQUFTO1FBQ2YsTUFBTUMsTUFBTXJFLFFBQVE7UUFDcEIsTUFBTXNFLE1BQU1sRSxTQUFTO1FBRXJCZixJQUFJbUQsUUFBUSxDQUFDb0IsWUFBWSxPQUFPUyxLQUFLQyxLQUFLRixRQUFRQTtJQUNwRDtJQUVBLGNBQWM7SUFDZCxJQUFJaEYsUUFBUW1GLFVBQVUsRUFBRTtRQUN0QixNQUFNQSxhQUFhLElBQUlDLEtBQUtwRixRQUFRbUYsVUFBVTtRQUM5QyxNQUFNRSxnQkFBZ0JGLFdBQVdHLGtCQUFrQixDQUFDLFNBQVM7WUFDM0RDLE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1FBQ1A7UUFFQXhGLElBQUkwRCxXQUFXLENBQUM7UUFDaEIxRCxJQUFJNEQsT0FBTyxDQUFDLGFBQWE7UUFDekI1RCxJQUFJMkQsWUFBWSxDQUFDbEQsYUFBYVcsQ0FBQyxFQUFFWCxhQUFhWSxDQUFDLEVBQUVaLGFBQWFhLENBQUM7UUFDL0R0QixJQUFJNkQsSUFBSSxDQUFDLGdCQUE4QixPQUFkdUIsZ0JBQWlCLElBQUlyRSxTQUFTO0lBQ3pEO0lBRUEsbUJBQW1CO0lBQ25CLElBQUloQixRQUFRMEYsTUFBTSxFQUFFO1FBQ2xCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsY0FBY0MseUJBQXlCN0YsUUFBUTBGLE1BQU07UUFDM0QsTUFBTUksWUFBWXJGLFNBQVNtRjtRQUUzQjNGLElBQUkwRCxXQUFXLENBQUM7UUFDaEIxRCxJQUFJMkQsWUFBWSxDQUFDa0MsVUFBVXpFLENBQUMsRUFBRXlFLFVBQVV4RSxDQUFDLEVBQUV3RSxVQUFVdkUsQ0FBQztRQUN0RHRCLElBQUk0RCxPQUFPLENBQUMsYUFBYTtRQUN6QjVELElBQUk2RCxJQUFJLENBQUM5RCxRQUFRMEYsTUFBTSxDQUFDSyxXQUFXLElBQUluRixRQUFRLElBQUkrRSxTQUFTO1lBQzFESyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQixPQUFPL0YsSUFBSWdHLE1BQU0sQ0FBQztBQUNwQixFQUFFO0FBRUY7O0NBRUMsR0FDRCxTQUFTSix5QkFBeUJILE1BQWM7SUFDOUMsT0FBUUEsT0FBT1EsV0FBVztRQUN4QixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTztJQUNYO0FBQ0Y7QUFXQSxTQUFTekYsU0FBUzBGLEdBQVc7SUFDM0JBLE1BQU1BLElBQUlDLE9BQU8sQ0FBQyxNQUFNO0lBRXhCLElBQUlELElBQUlFLE1BQU0sS0FBSyxHQUFHO1FBQ3BCRixNQUFNQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRTtJQUMzRDtJQUVBLE1BQU1HLFNBQVNDLFNBQVNKLEtBQUs7SUFDN0IsTUFBTTlFLElBQUksVUFBVyxLQUFNO0lBQzNCLE1BQU1DLElBQUksVUFBVyxJQUFLO0lBQzFCLE1BQU1DLElBQUkrRSxTQUFTO0lBRW5CLE9BQU87UUFBRWpGO1FBQUdDO1FBQUdDO0lBQUU7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdm91Y2hlclBERi9Wb3VjaGVyUERGLnRzeD9kYjhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqc1BERiBmcm9tIFwianNwZGZcIjtcbmltcG9ydCBRUkNvZGUgZnJvbSBcInFyY29kZVwiO1xuXG4vLyBmaWxlcGF0aDogL1VzZXJzL3JhZmFlbGJhYnl4by9Qcm9qZXRvcy9zeXN0ZW0tdm91Y2hlci9zcmMvY29tcG9uZW50cy92b3VjaGVyUERGL1ZvdWNoZXJQREYudHN4XG5leHBvcnQgaW50ZXJmYWNlIFZvdWNoZXIge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNvZGU6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGV4cGlyeURhdGU6IHN0cmluZyB8IG51bGw7XG4gIHJlZGVtcHRpb25zOiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICBhbW91bnQ/OiBudW1iZXI7XG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xuICBxckNvZGU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB0ZW1wbGF0ZT86IHN0cmluZztcbiAgcHJpbWFyeUNvbG9yPzogc3RyaW5nO1xuICBzZWNvbmRhcnlDb2xvcj86IHN0cmluZztcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xuICBsb2dvVXJsPzogc3RyaW5nO1xuICBzaG93TG9nbz86IGJvb2xlYW47XG4gIHNob3dRUkNvZGU/OiBib29sZWFuO1xuICBzaG93RXhwaXJ5RGF0ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWluaW1hbGlzdCBQREYgZm9yIHZvdWNoZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVZvdWNoZXJQREYgPSBhc3luYyAodm91Y2hlcjogVm91Y2hlcik6IFByb21pc2U8QmxvYj4gPT4ge1xuICBjb25zdCBkb2MgPSBuZXcganNQREYoe1xuICAgIG9yaWVudGF0aW9uOiBcImxhbmRzY2FwZVwiLFxuICAgIHVuaXQ6IFwibW1cIixcbiAgICBmb3JtYXQ6IFwiYTVcIixcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIG1pbmltYWxpc3QgY29sb3JzIC0gbW9ub2Nocm9tYXRpYyBzY2hlbWVcbiAgY29uc3QgcHJpbWFyeUNvbG9yID0gdm91Y2hlci5wcmltYXJ5Q29sb3IgfHwgXCIjMzMzMzMzXCI7XG4gIGNvbnN0IHNlY29uZGFyeUNvbG9yID0gdm91Y2hlci5zZWNvbmRhcnlDb2xvciB8fCBcIiM2NjY2NjZcIjtcbiAgY29uc3QgdGV4dENvbG9yID0gdm91Y2hlci50ZXh0Q29sb3IgfHwgXCIjMzMzMzMzXCI7XG5cbiAgLy8gQ29udmVydCBoZXggY29sb3JzIHRvIFJHQiBmb3IganNQREZcbiAgY29uc3QgcHJpbWFyeVJHQiA9IGhleFRvUmdiKHByaW1hcnlDb2xvcik7XG4gIGNvbnN0IHNlY29uZGFyeVJHQiA9IGhleFRvUmdiKHNlY29uZGFyeUNvbG9yKTtcbiAgY29uc3QgdGV4dFJHQiA9IGhleFRvUmdiKHRleHRDb2xvcik7XG5cbiAgLy8gR2V0IHBhZ2UgZGltZW5zaW9uc1xuICBjb25zdCB3aWR0aCA9IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRXaWR0aCgpO1xuICBjb25zdCBoZWlnaHQgPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCk7XG5cbiAgLy8gQWRkIGNsZWFuIHdoaXRlIGJhY2tncm91bmRcbiAgZG9jLnNldEZpbGxDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgZG9jLnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCwgXCJGXCIpO1xuXG4gIC8vIEFkZCBtaW5pbWFsIGJvcmRlclxuICBkb2Muc2V0RHJhd0NvbG9yKHByaW1hcnlSR0IuciwgcHJpbWFyeVJHQi5nLCBwcmltYXJ5UkdCLmIsIDAuMyk7XG4gIGRvYy5zZXRMaW5lV2lkdGgoMC41KTtcbiAgZG9jLnJlY3QoMTAsIDEwLCB3aWR0aCAtIDIwLCBoZWlnaHQgLSAyMCwgXCJTXCIpO1xuXG4gIC8vIEFkZCBjb21wYW55IGxvZ28gKGlmIGF2YWlsYWJsZSlcbiAgaWYgKHZvdWNoZXIubG9nb1VybCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IGxvZ28gVVJMIHRvIEJhc2U2NFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh2b3VjaGVyLmxvZ29VcmwpO1xuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgIGNvbnN0IGJhc2U2NFByb21pc2UgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYmFzZTY0TG9nbyA9IGF3YWl0IGJhc2U2NFByb21pc2U7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBpbWFnZSBlbGVtZW50IHRvIGdldCB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gYmFzZTY0TG9nbztcblxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IGltZy53aWR0aDtcbiAgICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgICAgLy8gRGVmaW5lIHRoZSBtYXhpbXVtIGFuZCBtaW5pbXVtIHdpZHRoIGFuZCBoZWlnaHQgZm9yIHRoZSBsb2dvXG4gICAgICBjb25zdCBtYXhXaWR0aCA9IDQwOyAvLyBNYXhpbXVtIHdpZHRoIGluIG1tXG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSAyMDsgLy8gTWF4aW11bSBoZWlnaHQgaW4gbW1cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBhc3BlY3QgcmF0aW9cbiAgICAgIGxldCBsb2dvV2lkdGggPSBtYXhXaWR0aDtcbiAgICAgIGxldCBsb2dvSGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXG4gICAgICBpZiAob3JpZ2luYWxXaWR0aCA+IG9yaWdpbmFsSGVpZ2h0KSB7XG4gICAgICAgIC8vIExhbmRzY2FwZSBsb2dvXG4gICAgICAgIGxvZ29IZWlnaHQgPSAob3JpZ2luYWxIZWlnaHQgLyBvcmlnaW5hbFdpZHRoKSAqIG1heFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUG9ydHJhaXQgb3Igc3F1YXJlIGxvZ29cbiAgICAgICAgbG9nb1dpZHRoID0gKG9yaWdpbmFsV2lkdGggLyBvcmlnaW5hbEhlaWdodCkgKiBtYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFBvc2l0aW9uIHRoZSBsb2dvXG4gICAgICBjb25zdCBsb2dvWCA9IHdpZHRoIC0gNjA7IC8vIFBvc2l0aW9uIFggKHJpZ2h0IHNpZGUpXG4gICAgICBjb25zdCBsb2dvWSA9IDIwOyAvLyBQb3NpdGlvbiBZIChhbGlnbmVkIHdpdGggdGhlIHRvcClcblxuICAgICAgZG9jLmFkZEltYWdlKGJhc2U2NExvZ28sIFwiUE5HXCIsIGxvZ29YLCBsb2dvWSwgbG9nb1dpZHRoLCBsb2dvSGVpZ2h0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgbG9nbzpcIiwgZXJyb3IpO1xuXG4gICAgICAvLyBDcmVhdGUgYSBwbGFjZWhvbGRlciBmb3IgdGhlIGxvZ29cbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyV2lkdGggPSA0MDtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVySGVpZ2h0ID0gMjA7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlclggPSB3aWR0aCAtIDYwO1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXJZID0gMjA7XG5cbiAgICAgIGRvYy5zZXRGaWxsQ29sb3IoMjQwLCAyNDAsIDI0MCk7XG4gICAgICBkb2MucmVjdChwbGFjZWhvbGRlclgsIHBsYWNlaG9sZGVyWSwgcGxhY2Vob2xkZXJXaWR0aCwgcGxhY2Vob2xkZXJIZWlnaHQsIFwiRlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGp1c3RlZCBwb3NpdGlvbiBmb3IgdGhlIHZvdWNoZXIgbmFtZVxuICBkb2Muc2V0Rm9udFNpemUoMjQpO1xuICBkb2Muc2V0VGV4dENvbG9yKHRleHRSR0IuciwgdGV4dFJHQi5nLCB0ZXh0UkdCLmIpO1xuICBkb2Muc2V0Rm9udChcImhlbHZldGljYVwiLCBcIm5vcm1hbFwiKTtcbiAgZG9jLnRleHQodm91Y2hlci5uYW1lIHx8IFwiR2lmdCBWb3VjaGVyXCIsIDIwLCA0MCk7IC8vIE5hbWUgb2YgdGhlIHZvdWNoZXIgKG1vdmVkIGRvd24pXG5cbiAgLy8gQWRqdXN0ZWQgcG9zaXRpb24gZm9yIHRoZSB2b3VjaGVyIGRlc2NyaXB0aW9uXG4gIGlmICh2b3VjaGVyLmRlc2NyaXB0aW9uKSB7XG4gICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICBkb2Muc2V0Rm9udChcImhlbHZldGljYVwiLCBcIm5vcm1hbFwiKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKHNlY29uZGFyeVJHQi5yLCBzZWNvbmRhcnlSR0IuZywgc2Vjb25kYXJ5UkdCLmIpO1xuICAgIGRvYy50ZXh0KHZvdWNoZXIuZGVzY3JpcHRpb24sIDIwLCA1MCwgeyBtYXhXaWR0aDogd2lkdGggLSA4MCB9KTsgLy8gRGVzY3JpcHRpb24gd2l0aCBhZGp1c3RlZCBtYXJnaW5cbiAgfVxuXG4gIC8vIERpdmlkZXIgcG9zaXRpb24gYWRqdXN0ZWRcbiAgY29uc3QgZGl2aWRlclkgPSB2b3VjaGVyLmRlc2NyaXB0aW9uID8gNjUgOiA1NTtcbiAgZG9jLnNldERyYXdDb2xvcihwcmltYXJ5UkdCLnIsIHByaW1hcnlSR0IuZywgcHJpbWFyeVJHQi5iLCAwLjIpO1xuICBkb2Muc2V0TGluZVdpZHRoKDAuMyk7XG4gIGRvYy5saW5lKDIwLCBkaXZpZGVyWSwgd2lkdGggLSAyMCwgZGl2aWRlclkpO1xuXG4gIC8vIEFtb3VudCBhbmQgY3VycmVuY3kgZGlzcGxheSAoaWYgYXZhaWxhYmxlKVxuICBjb25zdCBhbW91bnRZID0gZGl2aWRlclkgKyAxNTtcbiAgaWYgKHZvdWNoZXIuYW1vdW50ICYmIHZvdWNoZXIuY3VycmVuY3kpIHtcbiAgICBkb2Muc2V0Rm9udFNpemUoMTgpO1xuICAgIGRvYy5zZXRGb250KFwiaGVsdmV0aWNhXCIsIFwibm9ybWFsXCIpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3IodGV4dFJHQi5yLCB0ZXh0UkdCLmcsIHRleHRSR0IuYik7XG4gICAgZG9jLnRleHQoYCR7dm91Y2hlci5hbW91bnR9ICR7dm91Y2hlci5jdXJyZW5jeX1gLCAyMCwgYW1vdW50WSk7XG4gIH1cblxuICAvLyBWb3VjaGVyIGNvZGUgZGlzcGxheVxuICBjb25zdCBjb2RlWSA9IGFtb3VudFkgKyAxNTtcblxuICBkb2Muc2V0Rm9udFNpemUoOCk7XG4gIGRvYy5zZXRUZXh0Q29sb3Ioc2Vjb25kYXJ5UkdCLnIsIHNlY29uZGFyeVJHQi5nLCBzZWNvbmRhcnlSR0IuYik7XG4gIGRvYy5zZXRGb250KFwiaGVsdmV0aWNhXCIsIFwibm9ybWFsXCIpO1xuICBkb2MudGV4dChcIlZPVUNIRVIgQ09ERVwiLCAyMCwgY29kZVkpO1xuXG4gIGRvYy5zZXRGb250U2l6ZSgxNik7XG4gIGRvYy5zZXRUZXh0Q29sb3IodGV4dFJHQi5yLCB0ZXh0UkdCLmcsIHRleHRSR0IuYik7XG4gIGRvYy5zZXRGb250KFwiY291cmllclwiLCBcIm5vcm1hbFwiKTtcbiAgZG9jLnRleHQodm91Y2hlci5jb2RlLCAyMCwgY29kZVkgKyA4KTtcblxuICAvLyBHZW5lcmF0ZSBRUiBjb2RlIGZvciB0aGUgdm91Y2hlciBjb2RlXG4gIGxldCBxckNvZGVEYXRhID0gdm91Y2hlci5xckNvZGU7XG4gIGlmICghcXJDb2RlRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBxckNvZGVEYXRhID0gYXdhaXQgUVJDb2RlLnRvRGF0YVVSTCh2b3VjaGVyLmNvZGUsIHtcbiAgICAgICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWw6IFwiTVwiLFxuICAgICAgICBtYXJnaW46IDEsXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgZGFyazogdGV4dENvbG9yLFxuICAgICAgICAgIGxpZ2h0OiBcIiNGRkZGRkZcIixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VuZXJhdGluZyBRUiBDb2RlOlwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIFFSIGNvZGVcbiAgaWYgKHFyQ29kZURhdGEpIHtcbiAgICBjb25zdCBxclNpemUgPSAzMDtcbiAgICBjb25zdCBxclggPSB3aWR0aCAtIDUwO1xuICAgIGNvbnN0IHFyWSA9IGhlaWdodCAtIDUwO1xuXG4gICAgZG9jLmFkZEltYWdlKHFyQ29kZURhdGEsIFwiUE5HXCIsIHFyWCwgcXJZLCBxclNpemUsIHFyU2l6ZSk7XG4gIH1cblxuICAvLyBFeHBpcnkgZGF0ZVxuICBpZiAodm91Y2hlci5leHBpcnlEYXRlKSB7XG4gICAgY29uc3QgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKHZvdWNoZXIuZXhwaXJ5RGF0ZSk7XG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGV4cGlyeURhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKFwiZW4tVVNcIiwge1xuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgIH0pO1xuXG4gICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICBkb2Muc2V0Rm9udChcImhlbHZldGljYVwiLCBcIm5vcm1hbFwiKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKHNlY29uZGFyeVJHQi5yLCBzZWNvbmRhcnlSR0IuZywgc2Vjb25kYXJ5UkdCLmIpO1xuICAgIGRvYy50ZXh0KGBWYWxpZCB1bnRpbDogJHtmb3JtYXR0ZWREYXRlfWAsIDIwLCBoZWlnaHQgLSAyMCk7XG4gIH1cblxuICAvLyBTdGF0dXMgaW5kaWNhdG9yXG4gIGlmICh2b3VjaGVyLnN0YXR1cykge1xuICAgIGNvbnN0IHN0YXR1c1kgPSAyMDtcbiAgICBjb25zdCBzdGF0dXNDb2xvciA9IGdldE1pbmltYWxpc3RTdGF0dXNDb2xvcih2b3VjaGVyLnN0YXR1cyk7XG4gICAgY29uc3Qgc3RhdHVzUkdCID0gaGV4VG9SZ2Ioc3RhdHVzQ29sb3IpO1xuXG4gICAgZG9jLnNldEZvbnRTaXplKDEwKTtcbiAgICBkb2Muc2V0VGV4dENvbG9yKHN0YXR1c1JHQi5yLCBzdGF0dXNSR0IuZywgc3RhdHVzUkdCLmIpO1xuICAgIGRvYy5zZXRGb250KFwiaGVsdmV0aWNhXCIsIFwibm9ybWFsXCIpO1xuICAgIGRvYy50ZXh0KHZvdWNoZXIuc3RhdHVzLnRvVXBwZXJDYXNlKCksIHdpZHRoIC0gMjAsIHN0YXR1c1ksIHtcbiAgICAgIGFsaWduOiBcInJpZ2h0XCIsXG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIFBERiBhcyBhIEJsb2JcbiAgcmV0dXJuIGRvYy5vdXRwdXQoXCJibG9iXCIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbXV0ZWQgY29sb3IgYmFzZWQgb24gdm91Y2hlciBzdGF0dXMgZm9yIG1pbmltYWxpc3QgZGVzaWduXG4gKi9cbmZ1bmN0aW9uIGdldE1pbmltYWxpc3RTdGF0dXNDb2xvcihzdGF0dXM6IHN0cmluZyk6IHN0cmluZyB7XG4gIHN3aXRjaCAoc3RhdHVzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlIFwiYWN0aXZlXCI6XG4gICAgICByZXR1cm4gXCIjNEI5RDc0XCI7XG4gICAgY2FzZSBcInVzZWRcIjpcbiAgICAgIHJldHVybiBcIiM5Q0EzQUZcIjtcbiAgICBjYXNlIFwiZXhwaXJlZFwiOlxuICAgICAgcmV0dXJuIFwiI0RDNkY3OVwiO1xuICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICByZXR1cm4gXCIjRDdBNDVFXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIiM2QjcyODBcIjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IGNvbG9yIHRvIFJHQlxuICovXG5pbnRlcmZhY2UgUkdCIHtcbiAgcjogbnVtYmVyO1xuICBnOiBudW1iZXI7XG4gIGI6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gaGV4VG9SZ2IoaGV4OiBzdHJpbmcpOiBSR0Ige1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcblxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgIGhleCA9IGhleFswXSArIGhleFswXSArIGhleFsxXSArIGhleFsxXSArIGhleFsyXSArIGhleFsyXTtcbiAgfVxuXG4gIGNvbnN0IGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICBjb25zdCByID0gKGJpZ2ludCA+PiAxNikgJiAyNTU7XG4gIGNvbnN0IGcgPSAoYmlnaW50ID4+IDgpICYgMjU1O1xuICBjb25zdCBiID0gYmlnaW50ICYgMjU1O1xuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn0iXSwibmFtZXMiOlsianNQREYiLCJRUkNvZGUiLCJnZW5lcmF0ZVZvdWNoZXJQREYiLCJ2b3VjaGVyIiwiZG9jIiwib3JpZW50YXRpb24iLCJ1bml0IiwiZm9ybWF0IiwicHJpbWFyeUNvbG9yIiwic2Vjb25kYXJ5Q29sb3IiLCJ0ZXh0Q29sb3IiLCJwcmltYXJ5UkdCIiwiaGV4VG9SZ2IiLCJzZWNvbmRhcnlSR0IiLCJ0ZXh0UkdCIiwid2lkdGgiLCJpbnRlcm5hbCIsInBhZ2VTaXplIiwiZ2V0V2lkdGgiLCJoZWlnaHQiLCJnZXRIZWlnaHQiLCJzZXRGaWxsQ29sb3IiLCJyZWN0Iiwic2V0RHJhd0NvbG9yIiwiciIsImciLCJiIiwic2V0TGluZVdpZHRoIiwibG9nb1VybCIsInJlc3BvbnNlIiwiZmV0Y2giLCJibG9iIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImJhc2U2NFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiYmFzZTY0TG9nbyIsImltZyIsIkltYWdlIiwic3JjIiwib25sb2FkIiwib3JpZ2luYWxXaWR0aCIsIm9yaWdpbmFsSGVpZ2h0IiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJsb2dvV2lkdGgiLCJsb2dvSGVpZ2h0IiwibG9nb1giLCJsb2dvWSIsImFkZEltYWdlIiwiZXJyb3IiLCJjb25zb2xlIiwicGxhY2Vob2xkZXJXaWR0aCIsInBsYWNlaG9sZGVySGVpZ2h0IiwicGxhY2Vob2xkZXJYIiwicGxhY2Vob2xkZXJZIiwic2V0Rm9udFNpemUiLCJzZXRUZXh0Q29sb3IiLCJzZXRGb250IiwidGV4dCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImRpdmlkZXJZIiwibGluZSIsImFtb3VudFkiLCJhbW91bnQiLCJjdXJyZW5jeSIsImNvZGVZIiwiY29kZSIsInFyQ29kZURhdGEiLCJxckNvZGUiLCJ0b0RhdGFVUkwiLCJlcnJvckNvcnJlY3Rpb25MZXZlbCIsIm1hcmdpbiIsImNvbG9yIiwiZGFyayIsImxpZ2h0IiwicXJTaXplIiwicXJYIiwicXJZIiwiZXhwaXJ5RGF0ZSIsIkRhdGUiLCJmb3JtYXR0ZWREYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwieWVhciIsIm1vbnRoIiwiZGF5Iiwic3RhdHVzIiwic3RhdHVzWSIsInN0YXR1c0NvbG9yIiwiZ2V0TWluaW1hbGlzdFN0YXR1c0NvbG9yIiwic3RhdHVzUkdCIiwidG9VcHBlckNhc2UiLCJhbGlnbiIsIm91dHB1dCIsInRvTG93ZXJDYXNlIiwiaGV4IiwicmVwbGFjZSIsImxlbmd0aCIsImJpZ2ludCIsInBhcnNlSW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/voucherPDF/VoucherPDF.tsx\n"));

/***/ })

});