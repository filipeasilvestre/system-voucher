"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/components/voucherPDF/VoucherPDF.tsx":
/*!**************************************************!*\
  !*** ./src/components/voucherPDF/VoucherPDF.tsx ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateVoucherPDF: function() { return /* binding */ generateVoucherPDF; }\n/* harmony export */ });\n/* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jspdf */ \"(app-pages-browser)/./node_modules/jspdf/dist/jspdf.es.min.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! qrcode */ \"(app-pages-browser)/./node_modules/qrcode/lib/browser.js\");\n\n\n/**\n * Generates a minimalist PDF for vouchers\n */ const generateVoucherPDF = async (voucher)=>{\n    // Create a new PDF document\n    const doc = new jspdf__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        orientation: \"landscape\",\n        unit: \"mm\",\n        format: \"a5\"\n    });\n    // Define minimalist colors - monochromatic scheme\n    const primaryColor = voucher.primaryColor || \"#333333\";\n    const secondaryColor = voucher.secondaryColor || \"#666666\";\n    const textColor = voucher.textColor || \"#333333\";\n    const backgroundColor = \"#FFFFFF\";\n    // Convert hex colors to RGB for jsPDF\n    const primaryRGB = hexToRgb(primaryColor);\n    const secondaryRGB = hexToRgb(secondaryColor);\n    const textRGB = hexToRgb(textColor);\n    // Get page dimensions\n    const width = doc.internal.pageSize.getWidth();\n    const height = doc.internal.pageSize.getHeight();\n    // Add clean white background\n    doc.setFillColor(255, 255, 255);\n    doc.rect(0, 0, width, height, \"F\");\n    // Add minimal border\n    doc.setDrawColor(primaryRGB.r, primaryRGB.g, primaryRGB.b, 0.3);\n    doc.setLineWidth(0.5);\n    doc.rect(10, 10, width - 20, height - 20, \"S\");\n    // Add company logo (if available)\n    if (voucher.logoUrl) {\n        try {\n            // Convert logo URL to Base64\n            const response = await fetch(voucher.logoUrl);\n            const blob = await response.blob();\n            const reader = new FileReader();\n            const base64Promise = new Promise((resolve, reject)=>{\n                reader.onloadend = ()=>resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n            const base64Logo = await base64Promise;\n            // Create an image element to get the original dimensions\n            const img = new Image();\n            img.src = base64Logo;\n            await new Promise((resolve)=>{\n                img.onload = resolve;\n            });\n            const originalWidth = img.width;\n            const originalHeight = img.height;\n            // Define the maximum and minimum width and height for the logo\n            const maxWidth = 50; // Maximum width in mm\n            const maxHeight = 25; // Maximum height in mm\n            const minWidth = 30; // Minimum width in mm\n            const minHeight = 15; // Minimum height in mm\n            // Calculate the aspect ratio\n            let logoWidth = maxWidth;\n            let logoHeight = maxHeight;\n            if (originalWidth > originalHeight) {\n                // Landscape logo\n                logoHeight = originalHeight / originalWidth * maxWidth;\n                if (logoHeight < minHeight) {\n                    logoHeight = minHeight;\n                    logoWidth = originalWidth / originalHeight * minHeight;\n                }\n            } else {\n                // Portrait or square logo\n                logoWidth = originalWidth / originalHeight * maxHeight;\n                if (logoWidth < minWidth) {\n                    logoWidth = minWidth;\n                    logoHeight = originalHeight / originalWidth * minWidth;\n                }\n            }\n            // Position the logo\n            const logoX = width - 60; // Position X (right side)\n            const logoY = 40; // Position Y (adjusted to leave space from the top)\n            doc.addImage(base64Logo, \"PNG\", logoX, logoY, logoWidth, logoHeight);\n        } catch (error) {\n            console.error(\"Error loading logo:\", error);\n            // Create a placeholder for the logo\n            const placeholderWidth = 50;\n            const placeholderHeight = 25;\n            const placeholderX = width - 60;\n            const placeholderY = 40;\n            doc.setFillColor(240, 240, 240);\n            doc.rect(placeholderX, placeholderY, placeholderWidth, placeholderHeight, \"F\");\n        }\n    }\n    // Adjusted position for the voucher name\n    doc.setFontSize(24);\n    doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(voucher.name || \"Gift Voucher\", 20, 50); // Name of the voucher (moved down)\n    // Adjusted position for the voucher description\n    if (voucher.description) {\n        doc.setFontSize(10);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n        doc.text(voucher.description, 20, 60, {\n            maxWidth: width - 80\n        }); // Description with adjusted margin\n    }\n    // Divider position adjusted\n    const dividerY = voucher.description ? 78 : 68;\n    doc.setDrawColor(primaryRGB.r, primaryRGB.g, primaryRGB.b, 0.2);\n    doc.setLineWidth(0.3);\n    doc.line(20, dividerY, width - 20, dividerY);\n    // Amount and currency display (if available) - clean, modern\n    const amountY = dividerY + 15;\n    if (voucher.amount && voucher.currency) {\n        doc.setFontSize(18);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n    }\n    // Voucher code display - minimal but clear\n    const codeY = amountY + 15;\n    // Code label\n    doc.setFontSize(8);\n    doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.text(\"VOUCHER CODE\", 20, codeY);\n    // The code itself\n    doc.setFontSize(16);\n    doc.setTextColor(textRGB.r, textRGB.g, textRGB.b);\n    doc.setFont(\"courier\", \"normal\");\n    doc.text(voucher.code, 20, codeY + 8);\n    // Generate QR code for the voucher code\n    let qrCodeData = voucher.qrCode;\n    if (!qrCodeData) {\n        try {\n            qrCodeData = await qrcode__WEBPACK_IMPORTED_MODULE_1__.toDataURL(voucher.code, {\n                errorCorrectionLevel: \"M\",\n                margin: 1,\n                color: {\n                    dark: textColor,\n                    light: \"#FFFFFF\"\n                }\n            });\n        } catch (error) {\n            console.error(\"Error generating QR Code:\", error);\n        }\n    }\n    // Add QR code with minimal styling\n    if (qrCodeData) {\n        const qrSize = 30;\n        const qrX = width - 20 - qrSize;\n        const qrY = height - 20 - qrSize;\n        // Add the QR code\n        doc.addImage(qrCodeData, \"PNG\", qrX, qrY, qrSize, qrSize);\n    }\n    // Expiry date with clean formatting\n    if (voucher.expiryDate) {\n        const expiryDate = new Date(voucher.expiryDate);\n        const formattedDate = expiryDate.toLocaleDateString(\"en-US\", {\n            year: \"numeric\",\n            month: \"long\",\n            day: \"numeric\"\n        });\n        doc.setFontSize(10);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.setTextColor(secondaryRGB.r, secondaryRGB.g, secondaryRGB.b);\n        doc.text(\"Valid until: \".concat(formattedDate), 20, height - 20);\n    }\n    // Status indicator - minimalist pill\n    if (voucher.status) {\n        const statusY = 20;\n        const statusColor = getMinimalistStatusColor(voucher.status);\n        const statusRGB = hexToRgb(statusColor);\n        // Status text - no background, just text\n        doc.setFontSize(10);\n        doc.setTextColor(statusRGB.r, statusRGB.g, statusRGB.b);\n        doc.setFont(\"helvetica\", \"normal\");\n        doc.text(voucher.status.toUpperCase(), width - 20, statusY, {\n            align: \"right\"\n        });\n    }\n    // Save the PDF\n    doc.save(\"\".concat(voucher.name.replace(/\\s+/g, \"_\"), \".pdf\"));\n    return doc;\n};\n/**\n * Returns a muted color based on voucher status for minimalist design\n */ function getMinimalistStatusColor(status) {\n    switch(status.toLowerCase()){\n        case \"active\":\n            return \"#4B9D74\"; // Muted green\n        case \"used\":\n            return \"#9CA3AF\"; // Light gray\n        case \"expired\":\n            return \"#DC6F79\"; // Muted red\n        case \"pending\":\n            return \"#D7A45E\"; // Muted amber\n        default:\n            return \"#6B7280\"; // Neutral gray\n    }\n}\nfunction hexToRgb(hex) {\n    // Remove # if present\n    hex = hex.replace(/^#/, \"\");\n    // Handle shorthand hex\n    if (hex.length === 3) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    }\n    // Parse components\n    const bigint = parseInt(hex, 16);\n    const r = bigint >> 16 & 255;\n    const g = bigint >> 8 & 255;\n    const b = bigint & 255;\n    return {\n        r,\n        g,\n        b\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3ZvdWNoZXJQREYvVm91Y2hlclBERi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQ0U7QUFzQjVCOztDQUVDLEdBQ00sTUFBTUUscUJBQXFCLE9BQU9DO0lBQ3ZDLDRCQUE0QjtJQUM1QixNQUFNQyxNQUFNLElBQUlKLDZDQUFLQSxDQUFDO1FBQ3BCSyxhQUFhO1FBQ2JDLE1BQU07UUFDTkMsUUFBUTtJQUNWO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1DLGVBQWVMLFFBQVFLLFlBQVksSUFBSTtJQUM3QyxNQUFNQyxpQkFBaUJOLFFBQVFNLGNBQWMsSUFBSTtJQUNqRCxNQUFNQyxZQUFZUCxRQUFRTyxTQUFTLElBQUk7SUFDdkMsTUFBTUMsa0JBQWtCO0lBRXhCLHNDQUFzQztJQUN0QyxNQUFNQyxhQUFhQyxTQUFTTDtJQUM1QixNQUFNTSxlQUFlRCxTQUFTSjtJQUM5QixNQUFNTSxVQUFVRixTQUFTSDtJQUV6QixzQkFBc0I7SUFDdEIsTUFBTU0sUUFBUVosSUFBSWEsUUFBUSxDQUFDQyxRQUFRLENBQUNDLFFBQVE7SUFDNUMsTUFBTUMsU0FBU2hCLElBQUlhLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDRyxTQUFTO0lBRTlDLDZCQUE2QjtJQUM3QmpCLElBQUlrQixZQUFZLENBQUMsS0FBSyxLQUFLO0lBQzNCbEIsSUFBSW1CLElBQUksQ0FBQyxHQUFHLEdBQUdQLE9BQU9JLFFBQVE7SUFFOUIscUJBQXFCO0lBQ3JCaEIsSUFBSW9CLFlBQVksQ0FBQ1osV0FBV2EsQ0FBQyxFQUFFYixXQUFXYyxDQUFDLEVBQUVkLFdBQVdlLENBQUMsRUFBRTtJQUMzRHZCLElBQUl3QixZQUFZLENBQUM7SUFDakJ4QixJQUFJbUIsSUFBSSxDQUFDLElBQUksSUFBSVAsUUFBUSxJQUFJSSxTQUFTLElBQUk7SUFFNUMsa0NBQWtDO0lBQ2xDLElBQUlqQixRQUFRMEIsT0FBTyxFQUFFO1FBQ25CLElBQUk7WUFDRiw2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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3ZvdWNoZXJQREYvVm91Y2hlclBERi50c3g/ZGI4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQganNQREYgZnJvbSBcImpzcGRmXCI7XG5pbXBvcnQgUVJDb2RlIGZyb20gXCJxcmNvZGVcIjtcblxuaW50ZXJmYWNlIFZvdWNoZXIge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGNvZGU6IHN0cmluZztcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGV4cGlyeURhdGU6IHN0cmluZyB8IG51bGw7XG4gIHJlZGVtcHRpb25zOiBudW1iZXI7XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICBhbW91bnQ/OiBudW1iZXI7XG4gIGN1cnJlbmN5Pzogc3RyaW5nO1xuICBxckNvZGU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB0ZW1wbGF0ZT86IHN0cmluZztcbiAgcHJpbWFyeUNvbG9yPzogc3RyaW5nO1xuICBzZWNvbmRhcnlDb2xvcj86IHN0cmluZztcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xuICBsb2dvVXJsPzogc3RyaW5nO1xuICBzaG93QmFyY29kZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWluaW1hbGlzdCBQREYgZm9yIHZvdWNoZXJzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVZvdWNoZXJQREYgPSBhc3luYyAodm91Y2hlcjogVm91Y2hlcikgPT4ge1xuICAvLyBDcmVhdGUgYSBuZXcgUERGIGRvY3VtZW50XG4gIGNvbnN0IGRvYyA9IG5ldyBqc1BERih7XG4gICAgb3JpZW50YXRpb246IFwibGFuZHNjYXBlXCIsXG4gICAgdW5pdDogXCJtbVwiLFxuICAgIGZvcm1hdDogXCJhNVwiLFxuICB9KTtcblxuICAvLyBEZWZpbmUgbWluaW1hbGlzdCBjb2xvcnMgLSBtb25vY2hyb21hdGljIHNjaGVtZVxuICBjb25zdCBwcmltYXJ5Q29sb3IgPSB2b3VjaGVyLnByaW1hcnlDb2xvciB8fCBcIiMzMzMzMzNcIjtcbiAgY29uc3Qgc2Vjb25kYXJ5Q29sb3IgPSB2b3VjaGVyLnNlY29uZGFyeUNvbG9yIHx8IFwiIzY2NjY2NlwiO1xuICBjb25zdCB0ZXh0Q29sb3IgPSB2b3VjaGVyLnRleHRDb2xvciB8fCBcIiMzMzMzMzNcIjtcbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gXCIjRkZGRkZGXCI7XG5cbiAgLy8gQ29udmVydCBoZXggY29sb3JzIHRvIFJHQiBmb3IganNQREZcbiAgY29uc3QgcHJpbWFyeVJHQiA9IGhleFRvUmdiKHByaW1hcnlDb2xvcik7XG4gIGNvbnN0IHNlY29uZGFyeVJHQiA9IGhleFRvUmdiKHNlY29uZGFyeUNvbG9yKTtcbiAgY29uc3QgdGV4dFJHQiA9IGhleFRvUmdiKHRleHRDb2xvcik7XG5cbiAgLy8gR2V0IHBhZ2UgZGltZW5zaW9uc1xuICBjb25zdCB3aWR0aCA9IGRvYy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRXaWR0aCgpO1xuICBjb25zdCBoZWlnaHQgPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuZ2V0SGVpZ2h0KCk7XG5cbiAgLy8gQWRkIGNsZWFuIHdoaXRlIGJhY2tncm91bmRcbiAgZG9jLnNldEZpbGxDb2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgZG9jLnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCwgXCJGXCIpO1xuXG4gIC8vIEFkZCBtaW5pbWFsIGJvcmRlclxuICBkb2Muc2V0RHJhd0NvbG9yKHByaW1hcnlSR0IuciwgcHJpbWFyeVJHQi5nLCBwcmltYXJ5UkdCLmIsIDAuMyk7XG4gIGRvYy5zZXRMaW5lV2lkdGgoMC41KTtcbiAgZG9jLnJlY3QoMTAsIDEwLCB3aWR0aCAtIDIwLCBoZWlnaHQgLSAyMCwgXCJTXCIpO1xuXG4vLyBBZGQgY29tcGFueSBsb2dvIChpZiBhdmFpbGFibGUpXG5pZiAodm91Y2hlci5sb2dvVXJsKSB7XG4gIHRyeSB7XG4gICAgLy8gQ29udmVydCBsb2dvIFVSTCB0byBCYXNlNjRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHZvdWNoZXIubG9nb1VybCk7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgY29uc3QgYmFzZTY0UHJvbWlzZSA9IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGJhc2U2NExvZ28gPSBhd2FpdCBiYXNlNjRQcm9taXNlO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGltYWdlIGVsZW1lbnQgdG8gZ2V0IHRoZSBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLnNyYyA9IGJhc2U2NExvZ287XG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaW1nLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvcmlnaW5hbFdpZHRoID0gaW1nLndpZHRoO1xuICAgIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgIC8vIERlZmluZSB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB3aWR0aCBhbmQgaGVpZ2h0IGZvciB0aGUgbG9nb1xuICAgIGNvbnN0IG1heFdpZHRoID0gNTA7IC8vIE1heGltdW0gd2lkdGggaW4gbW1cbiAgICBjb25zdCBtYXhIZWlnaHQgPSAyNTsgLy8gTWF4aW11bSBoZWlnaHQgaW4gbW1cbiAgICBjb25zdCBtaW5XaWR0aCA9IDMwOyAvLyBNaW5pbXVtIHdpZHRoIGluIG1tXG4gICAgY29uc3QgbWluSGVpZ2h0ID0gMTU7IC8vIE1pbmltdW0gaGVpZ2h0IGluIG1tXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFzcGVjdCByYXRpb1xuICAgIGxldCBsb2dvV2lkdGggPSBtYXhXaWR0aDtcbiAgICBsZXQgbG9nb0hlaWdodCA9IG1heEhlaWdodDtcblxuICAgIGlmIChvcmlnaW5hbFdpZHRoID4gb3JpZ2luYWxIZWlnaHQpIHtcbiAgICAgIC8vIExhbmRzY2FwZSBsb2dvXG4gICAgICBsb2dvSGVpZ2h0ID0gKG9yaWdpbmFsSGVpZ2h0IC8gb3JpZ2luYWxXaWR0aCkgKiBtYXhXaWR0aDtcbiAgICAgIGlmIChsb2dvSGVpZ2h0IDwgbWluSGVpZ2h0KSB7XG4gICAgICAgIGxvZ29IZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICAgIGxvZ29XaWR0aCA9IChvcmlnaW5hbFdpZHRoIC8gb3JpZ2luYWxIZWlnaHQpICogbWluSGVpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb3J0cmFpdCBvciBzcXVhcmUgbG9nb1xuICAgICAgbG9nb1dpZHRoID0gKG9yaWdpbmFsV2lkdGggLyBvcmlnaW5hbEhlaWdodCkgKiBtYXhIZWlnaHQ7XG4gICAgICBpZiAobG9nb1dpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgICAgbG9nb1dpZHRoID0gbWluV2lkdGg7XG4gICAgICAgIGxvZ29IZWlnaHQgPSAob3JpZ2luYWxIZWlnaHQgLyBvcmlnaW5hbFdpZHRoKSAqIG1pbldpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBvc2l0aW9uIHRoZSBsb2dvXG4gICAgY29uc3QgbG9nb1ggPSB3aWR0aCAtIDYwOyAvLyBQb3NpdGlvbiBYIChyaWdodCBzaWRlKVxuICAgIGNvbnN0IGxvZ29ZID0gNDA7IC8vIFBvc2l0aW9uIFkgKGFkanVzdGVkIHRvIGxlYXZlIHNwYWNlIGZyb20gdGhlIHRvcClcblxuICAgIGRvYy5hZGRJbWFnZShiYXNlNjRMb2dvLCBcIlBOR1wiLCBsb2dvWCwgbG9nb1ksIGxvZ29XaWR0aCwgbG9nb0hlaWdodCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgbG9nbzpcIiwgZXJyb3IpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSBsb2dvXG4gICAgY29uc3QgcGxhY2Vob2xkZXJXaWR0aCA9IDUwO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVySGVpZ2h0ID0gMjU7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJYID0gd2lkdGggLSA2MDtcbiAgICBjb25zdCBwbGFjZWhvbGRlclkgPSA0MDtcblxuICAgIGRvYy5zZXRGaWxsQ29sb3IoMjQwLCAyNDAsIDI0MCk7XG4gICAgZG9jLnJlY3QocGxhY2Vob2xkZXJYLCBwbGFjZWhvbGRlclksIHBsYWNlaG9sZGVyV2lkdGgsIHBsYWNlaG9sZGVySGVpZ2h0LCBcIkZcIik7XG4gIH1cbn1cbiAgLy8gQWRqdXN0ZWQgcG9zaXRpb24gZm9yIHRoZSB2b3VjaGVyIG5hbWVcbiAgZG9jLnNldEZvbnRTaXplKDI0KTtcbiAgZG9jLnNldFRleHRDb2xvcih0ZXh0UkdCLnIsIHRleHRSR0IuZywgdGV4dFJHQi5iKTtcbiAgZG9jLnNldEZvbnQoXCJoZWx2ZXRpY2FcIiwgXCJub3JtYWxcIik7XG4gIGRvYy50ZXh0KHZvdWNoZXIubmFtZSB8fCBcIkdpZnQgVm91Y2hlclwiLCAyMCwgNTApOyAvLyBOYW1lIG9mIHRoZSB2b3VjaGVyIChtb3ZlZCBkb3duKVxuXG4gIC8vIEFkanVzdGVkIHBvc2l0aW9uIGZvciB0aGUgdm91Y2hlciBkZXNjcmlwdGlvblxuICBpZiAodm91Y2hlci5kZXNjcmlwdGlvbikge1xuICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgZG9jLnNldEZvbnQoXCJoZWx2ZXRpY2FcIiwgXCJub3JtYWxcIik7XG4gICAgZG9jLnNldFRleHRDb2xvcihzZWNvbmRhcnlSR0Iuciwgc2Vjb25kYXJ5UkdCLmcsIHNlY29uZGFyeVJHQi5iKTtcbiAgICBkb2MudGV4dCh2b3VjaGVyLmRlc2NyaXB0aW9uLCAyMCwgNjAsIHsgbWF4V2lkdGg6IHdpZHRoIC0gODAgfSk7IC8vIERlc2NyaXB0aW9uIHdpdGggYWRqdXN0ZWQgbWFyZ2luXG4gIH1cblxuICAvLyBEaXZpZGVyIHBvc2l0aW9uIGFkanVzdGVkXG4gIGNvbnN0IGRpdmlkZXJZID0gdm91Y2hlci5kZXNjcmlwdGlvbiA/IDc4IDogNjg7XG4gIGRvYy5zZXREcmF3Q29sb3IocHJpbWFyeVJHQi5yLCBwcmltYXJ5UkdCLmcsIHByaW1hcnlSR0IuYiwgMC4yKTtcbiAgZG9jLnNldExpbmVXaWR0aCgwLjMpO1xuICBkb2MubGluZSgyMCwgZGl2aWRlclksIHdpZHRoIC0gMjAsIGRpdmlkZXJZKTtcblxuICAvLyBBbW91bnQgYW5kIGN1cnJlbmN5IGRpc3BsYXkgKGlmIGF2YWlsYWJsZSkgLSBjbGVhbiwgbW9kZXJuXG4gIGNvbnN0IGFtb3VudFkgPSBkaXZpZGVyWSArIDE1O1xuICBpZiAodm91Y2hlci5hbW91bnQgJiYgdm91Y2hlci5jdXJyZW5jeSkge1xuICAgIGRvYy5zZXRGb250U2l6ZSgxOCk7XG4gICAgZG9jLnNldEZvbnQoXCJoZWx2ZXRpY2FcIiwgXCJub3JtYWxcIik7XG4gICAgZG9jLnNldFRleHRDb2xvcih0ZXh0UkdCLnIsIHRleHRSR0IuZywgdGV4dFJHQi5iKTtcbiAgfVxuXG4gIC8vIFZvdWNoZXIgY29kZSBkaXNwbGF5IC0gbWluaW1hbCBidXQgY2xlYXJcbiAgY29uc3QgY29kZVkgPSBhbW91bnRZICsgMTU7XG5cbiAgLy8gQ29kZSBsYWJlbFxuICBkb2Muc2V0Rm9udFNpemUoOCk7XG4gIGRvYy5zZXRUZXh0Q29sb3Ioc2Vjb25kYXJ5UkdCLnIsIHNlY29uZGFyeVJHQi5nLCBzZWNvbmRhcnlSR0IuYik7XG4gIGRvYy5zZXRGb250KFwiaGVsdmV0aWNhXCIsIFwibm9ybWFsXCIpO1xuICBkb2MudGV4dChcIlZPVUNIRVIgQ09ERVwiLCAyMCwgY29kZVkpO1xuXG4gIC8vIFRoZSBjb2RlIGl0c2VsZlxuICBkb2Muc2V0Rm9udFNpemUoMTYpO1xuICBkb2Muc2V0VGV4dENvbG9yKHRleHRSR0IuciwgdGV4dFJHQi5nLCB0ZXh0UkdCLmIpO1xuICBkb2Muc2V0Rm9udChcImNvdXJpZXJcIiwgXCJub3JtYWxcIik7XG4gIGRvYy50ZXh0KHZvdWNoZXIuY29kZSwgMjAsIGNvZGVZICsgOCk7XG5cbiAgLy8gR2VuZXJhdGUgUVIgY29kZSBmb3IgdGhlIHZvdWNoZXIgY29kZVxuICBsZXQgcXJDb2RlRGF0YSA9IHZvdWNoZXIucXJDb2RlO1xuICBpZiAoIXFyQ29kZURhdGEpIHtcbiAgICB0cnkge1xuICAgICAgcXJDb2RlRGF0YSA9IGF3YWl0IFFSQ29kZS50b0RhdGFVUkwodm91Y2hlci5jb2RlLCB7XG4gICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsOiBcIk1cIixcbiAgICAgICAgbWFyZ2luOiAxLFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGRhcms6IHRleHRDb2xvcixcbiAgICAgICAgICBsaWdodDogXCIjRkZGRkZGXCIsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgUVIgQ29kZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBRUiBjb2RlIHdpdGggbWluaW1hbCBzdHlsaW5nXG4gIGlmIChxckNvZGVEYXRhKSB7XG4gICAgY29uc3QgcXJTaXplID0gMzA7XG4gICAgY29uc3QgcXJYID0gd2lkdGggLSAyMCAtIHFyU2l6ZTtcbiAgICBjb25zdCBxclkgPSBoZWlnaHQgLSAyMCAtIHFyU2l6ZTtcblxuICAgIC8vIEFkZCB0aGUgUVIgY29kZVxuICAgIGRvYy5hZGRJbWFnZShxckNvZGVEYXRhLCBcIlBOR1wiLCBxclgsIHFyWSwgcXJTaXplLCBxclNpemUpO1xuICB9XG5cbiAgLy8gRXhwaXJ5IGRhdGUgd2l0aCBjbGVhbiBmb3JtYXR0aW5nXG4gIGlmICh2b3VjaGVyLmV4cGlyeURhdGUpIHtcbiAgICBjb25zdCBleHBpcnlEYXRlID0gbmV3IERhdGUodm91Y2hlci5leHBpcnlEYXRlKTtcbiAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gZXhwaXJ5RGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoXCJlbi1VU1wiLCB7XG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcImxvbmdcIixcbiAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgfSk7XG5cbiAgICBkb2Muc2V0Rm9udFNpemUoMTApO1xuICAgIGRvYy5zZXRGb250KFwiaGVsdmV0aWNhXCIsIFwibm9ybWFsXCIpO1xuICAgIGRvYy5zZXRUZXh0Q29sb3Ioc2Vjb25kYXJ5UkdCLnIsIHNlY29uZGFyeVJHQi5nLCBzZWNvbmRhcnlSR0IuYik7XG4gICAgZG9jLnRleHQoYFZhbGlkIHVudGlsOiAke2Zvcm1hdHRlZERhdGV9YCwgMjAsIGhlaWdodCAtIDIwKTtcbiAgfVxuXG4gIC8vIFN0YXR1cyBpbmRpY2F0b3IgLSBtaW5pbWFsaXN0IHBpbGxcbiAgaWYgKHZvdWNoZXIuc3RhdHVzKSB7XG4gICAgY29uc3Qgc3RhdHVzWSA9IDIwO1xuICAgIGNvbnN0IHN0YXR1c0NvbG9yID0gZ2V0TWluaW1hbGlzdFN0YXR1c0NvbG9yKHZvdWNoZXIuc3RhdHVzKTtcbiAgICBjb25zdCBzdGF0dXNSR0IgPSBoZXhUb1JnYihzdGF0dXNDb2xvcik7XG5cbiAgICAvLyBTdGF0dXMgdGV4dCAtIG5vIGJhY2tncm91bmQsIGp1c3QgdGV4dFxuICAgIGRvYy5zZXRGb250U2l6ZSgxMCk7XG4gICAgZG9jLnNldFRleHRDb2xvcihzdGF0dXNSR0Iuciwgc3RhdHVzUkdCLmcsIHN0YXR1c1JHQi5iKTtcbiAgICBkb2Muc2V0Rm9udChcImhlbHZldGljYVwiLCBcIm5vcm1hbFwiKTtcbiAgICBkb2MudGV4dCh2b3VjaGVyLnN0YXR1cy50b1VwcGVyQ2FzZSgpLCB3aWR0aCAtIDIwLCBzdGF0dXNZLCB7XG4gICAgICBhbGlnbjogXCJyaWdodFwiLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2F2ZSB0aGUgUERGXG4gIGRvYy5zYXZlKGAke3ZvdWNoZXIubmFtZS5yZXBsYWNlKC9cXHMrL2csIFwiX1wiKX0ucGRmYCk7XG5cbiAgcmV0dXJuIGRvYztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG11dGVkIGNvbG9yIGJhc2VkIG9uIHZvdWNoZXIgc3RhdHVzIGZvciBtaW5pbWFsaXN0IGRlc2lnblxuICovXG5mdW5jdGlvbiBnZXRNaW5pbWFsaXN0U3RhdHVzQ29sb3Ioc3RhdHVzOiBzdHJpbmcpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHN0YXR1cy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImFjdGl2ZVwiOlxuICAgICAgcmV0dXJuIFwiIzRCOUQ3NFwiOyAvLyBNdXRlZCBncmVlblxuICAgIGNhc2UgXCJ1c2VkXCI6XG4gICAgICByZXR1cm4gXCIjOUNBM0FGXCI7IC8vIExpZ2h0IGdyYXlcbiAgICBjYXNlIFwiZXhwaXJlZFwiOlxuICAgICAgcmV0dXJuIFwiI0RDNkY3OVwiOyAvLyBNdXRlZCByZWRcbiAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgcmV0dXJuIFwiI0Q3QTQ1RVwiOyAvLyBNdXRlZCBhbWJlclxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIjNkI3MjgwXCI7IC8vIE5ldXRyYWwgZ3JheVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgdG8gUkdCXG4gKi9cbmludGVyZmFjZSBSR0Ige1xuICByOiBudW1iZXI7XG4gIGc6IG51bWJlcjtcbiAgYjogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBoZXhUb1JnYihoZXg6IHN0cmluZyk6IFJHQiB7XG4gIC8vIFJlbW92ZSAjIGlmIHByZXNlbnRcbiAgaGV4ID0gaGV4LnJlcGxhY2UoL14jLywgXCJcIik7XG5cbiAgLy8gSGFuZGxlIHNob3J0aGFuZCBoZXhcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl07XG4gIH1cblxuICAvLyBQYXJzZSBjb21wb25lbnRzXG4gIGNvbnN0IGJpZ2ludCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICBjb25zdCByID0gKGJpZ2ludCA+PiAxNikgJiAyNTU7XG4gIGNvbnN0IGcgPSAoYmlnaW50ID4+IDgpICYgMjU1O1xuICBjb25zdCBiID0gYmlnaW50ICYgMjU1O1xuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn1cbiJdLCJuYW1lcyI6WyJqc1BERiIsIlFSQ29kZSIsImdlbmVyYXRlVm91Y2hlclBERiIsInZvdWNoZXIiLCJkb2MiLCJvcmllbnRhdGlvbiIsInVuaXQiLCJmb3JtYXQiLCJwcmltYXJ5Q29sb3IiLCJzZWNvbmRhcnlDb2xvciIsInRleHRDb2xvciIsImJhY2tncm91bmRDb2xvciIsInByaW1hcnlSR0IiLCJoZXhUb1JnYiIsInNlY29uZGFyeVJHQiIsInRleHRSR0IiLCJ3aWR0aCIsImludGVybmFsIiwicGFnZVNpemUiLCJnZXRXaWR0aCIsImhlaWdodCIsImdldEhlaWdodCIsInNldEZpbGxDb2xvciIsInJlY3QiLCJzZXREcmF3Q29sb3IiLCJyIiwiZyIsImIiLCJzZXRMaW5lV2lkdGgiLCJsb2dvVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiYmFzZTY0UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib25sb2FkZW5kIiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJiYXNlNjRMb2dvIiwiaW1nIiwiSW1hZ2UiLCJzcmMiLCJvbmxvYWQiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibG9nb1dpZHRoIiwibG9nb0hlaWdodCIsImxvZ29YIiwibG9nb1kiLCJhZGRJbWFnZSIsImVycm9yIiwiY29uc29sZSIsInBsYWNlaG9sZGVyV2lkdGgiLCJwbGFjZWhvbGRlckhlaWdodCIsInBsYWNlaG9sZGVyWCIsInBsYWNlaG9sZGVyWSIsInNldEZvbnRTaXplIiwic2V0VGV4dENvbG9yIiwic2V0Rm9udCIsInRleHQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJkaXZpZGVyWSIsImxpbmUiLCJhbW91bnRZIiwiYW1vdW50IiwiY3VycmVuY3kiLCJjb2RlWSIsImNvZGUiLCJxckNvZGVEYXRhIiwicXJDb2RlIiwidG9EYXRhVVJMIiwiZXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJtYXJnaW4iLCJjb2xvciIsImRhcmsiLCJsaWdodCIsInFyU2l6ZSIsInFyWCIsInFyWSIsImV4cGlyeURhdGUiLCJEYXRlIiwiZm9ybWF0dGVkRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInllYXIiLCJtb250aCIsImRheSIsInN0YXR1cyIsInN0YXR1c1kiLCJzdGF0dXNDb2xvciIsImdldE1pbmltYWxpc3RTdGF0dXNDb2xvciIsInN0YXR1c1JHQiIsInRvVXBwZXJDYXNlIiwiYWxpZ24iLCJzYXZlIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiaGV4IiwibGVuZ3RoIiwiYmlnaW50IiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/voucherPDF/VoucherPDF.tsx\n"));

/***/ })

});